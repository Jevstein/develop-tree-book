[TOC]

# 细品CRC校验原理

## 1.CRC校验的原理

![](./images/CRC.数据.png)

​	**根本思想**：发送端欲发送一个**原始数据帧**到接收端，首先发送端和接收端要选定一个共同的**除数**；然后发送端通过这个除数计算出一个**校验码**，附加到原始数据帧的后面组成一个**新的数据帧**，再将新的数据帧发往接收端；到达接收端后，将收到新的数据帧采用“模2除法”除以选定的**除数**，若结果有余数不为0则表明该数据帧在传输过程中出现了差错！否则，成功，且右移“**除数**位数 - 1”位得到的结果即为**原始数据帧**。

​	【**说明**】：“模2除法”与“算术除法”类似，但它既不向上位借位，也不比较除数和被除数的相同位数值的大小，只要以相同位数进行相除即可。相当于二进制中的逻辑异或运算，即比较后，两者对应位相同则结果为“0”，不同则结果为“1”

```shell
#1.模2加法: (无进位，也无借位)
	1 + 1 = 0,
	0 + 1 = 1，
	0 + 0 = 0
	
#2.模2减法: (无进位，无借位)
  1 - 1 = 0，
  0 - 1 = 1，
  1 - 0 = 1，
  0 - 0 = 0
```

模2除法和模2乘法示例，如图：

![模2除法和模2乘法示例](./images/CRC.模2乘除法.png)



 CRC校验原理的具体步骤如下：

* **1.选择除数**：

  ​	一个用于在接收端进行校验时，对接收的新帧进行除法运算的**除数**。注意这是二进制比较特串，通常是以多项方式表示，所以CRC又称**多项式编码方法**，这个多项式也称之为“**生成多项式**”。这个除数可以随机选择，也可按标准选择，具体在后面介绍。

* **2.计算校验码**：

  ​	看所选定的**除数**二进制位数（假设为k位），然后在要发送的**原始数据帧**（假设为m位）后面加上k-1位“0”，得到**新帧**（一共m+k-1位）；该新帧再以“模2除法”方式除以上面的**除数**，最后得到的**余数**（也是二进制的比特串）就是该帧的**CRC校验码**，也称之为**FCS**（**帧校验序列**）。

  ​	但要注意的是，<font color=red>余数的位数一定要是比除数位数只能少一位，哪怕前面位是0，甚至是全为0（附带好整除时）也都不能省略。</font>

* **3.带校验码的新帧**：

  ​	将上面的**校验码**附加在**原始数据帧**后面形成**新的数据帧**，发送端即发生这个“新的数据帧”到接收端。注意：此时“新的数据帧（m位）”和上一步的“新帧（m+k-1位）”不同。

* **4.校验结果**：

  ​	接收端收到“新的数据帧”后，再将其以“模2除法”方式除以前面选择的**除数**。如果余数为0，则表明该帧在传输过程中没出错，否则出现了差错！

总而言之，CRC校验中有两个关键点：一是要预先确定一个发送端和接收端都用来作为**除数**的二进制比特串（或多项式）；二是把原始帧与上面选定的除进行二进制除法运算，**计算出FCS**。前者可以随机选择，也可按国际上通行的标准选择，但最高位和最低位必须均为“1”，如在IBM的SDLC（同步数据链路控制）规程中使用的CRC-16（也就是这个除数一共是17位）生成多项式g（x）= x16 + x15 + x2 +1（对应二进制比特串为：11000000000000101）；而在ISO HDLC（高级数据链路控制）规程、ITU的SDLC、X.25、V.34、V.41、V.42等中使用CCITT-16生成多项式g（x）=x16 + x15 + x5 +1（对应二进制比特串为：11000000000100001）。



## 2.CRC的计算示例

​	由以上分析可知，既然除数是"随机"或者"按标准选定"的，所以CRC校验的关键是如何求出**余数**(即CRC校验码)。下面举例说明计算过程：
​	假设选择的CRC生成多项式为G(X) = X^4 + X^3 + 1，要求出二进制序列10110011的CRC校验码。

计算过程：

* 1.将生成多项式G(x) = X^4 + X^3 + 1 转换成二进制数：11001

  ```shell
  	由G(x) = X^4 + X^3 + 1可知：它一共是5位（总位数 = 最高位的幂次 + 1，即 4 + 1 = 5），再根据多项式各项的含义（多项式只列出二进制值为1的位，即该二进制数的第4位、第3位、第0位的二进制均为1，其它位均为0）得知，该二进制比特串为11001
  ```

* 2.计算CRC校验码：0100

  ```shell
  因为生成多项式的位数为5，根据前面的介绍，得知CRC校验码的位数为4（校验码的位数 = 生成多项式的位数 - 1 = 生成多项式的最高次数 = 4）；又因原数据帧为10110011，则在它后面再加4个0，得到101100110000；最后，把这个数以“模2除法”方式除以生成多项式，得到的余数，即为CRC校验码（0100）。
  ```

  如图：

  ![校验码计算](./images/CRC.校验码计算.png)

* 3.构造新的数据帧：10110011 0100

  ```shell
  把上一步计算得到的CRC校验码0100，替换原始帧101100110000后面的四个“0”，得到新帧101100110100。再把这个新帧发送到接收端
  ```

* 4.校验结果：

  ```shell
  当以上新帧到达接收端后，接收端会把这个新帧再用上面选定的除数11001以“模2除法”方式去除，验证余数是否为0，如果为0，则证明该帧数据在传输过程中没有出现差错，否则出现了差错
  ```

  如图：

  ![校验结果](./images/CRC.校验结果.png)



## 3.CRC的c代码实现

https://blog.csdn.net/Shayne_Lee/article/details/88087518?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase

 ```c
void send_with_crc(int data);

void recv_with_crc(int data);
 ```



> 巨人的肩膀：
>
> [CRC码计算及校验原理的最通俗诠释](https://blog.csdn.net/lycb_gz/article/details/8201987)

