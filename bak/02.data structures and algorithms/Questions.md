<!-- vscode-markdown-toc -->
* 1. [其它](#)
	* 1.1. [漫画：如何实现大整数相加？](#-1)
	* 1.2. [漫画：如何实现大整数相乘？](#-1)
	* 1.3. [漫画：寻找无序数组的第k大元素](#k)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
# 问题

##  1. <a name=''></a>其它

###  1.1. <a name='-1'></a>漫画：如何实现大整数相加？
> [漫画：如何实现大整数相加？](https://mp.weixin.qq.com/s/NQqGsAlxdatfB8TkYlF7Ww)  

* 1.思路:  数组形式，竖式计算
    * step1：申请两个`参数数组param`。把整数`倒序存储`，整数的个位存于数组0下标位置，最高位存于数组长度-1下标位置(之所以倒序存储，更加符合我们从左到右访问数组的习惯)。
    * step2: 申请一个`结果数组result`，数组大小=max(len(参数数组1)， len(参数数组2))。  
    * step3: 遍历`参数数组`，从第一位起，`两数相加`，`累计进result`，`进位1保存到下一位`。
    * step4: 以此类推，直到结束。 

* 2.时间复杂度: O(n)  
    给定大整数最长位数n, 则创建数组、按位计算、结果逆序的时间复杂度均为O(n),所以整体的时间复杂度为O(n)

* 3.优化： 
    整数无需拆分过细，拆分到可以被直接计算的程度就够了。如：int类型的取值范围是-2147483648 ~ 2147483647，最多有10位整数。为了防止溢出，我们可以把大整数的每9位作为数组的一个元素，进行加法运算。这样一来，便压缩了9倍。

* 4.场景  
    RSA加解密需要用到两个大素数

* 5.实现  
    略。dnpractice/../BigNum.cpp

###  1.2. <a name='-1'></a>漫画：如何实现大整数相乘？
> [漫画：如何实现大整数相乘？](https://mp.weixin.qq.com/s/nwc393ctWmPDEBLAy8_stA)  

* 思路：
    * 1.类似于上题大整数相加，竖式计算: 从个位开始，每一位与另一个整数的每位数相乘，然后结果相加。  
    复杂度：O(m*n)、 O(n^2)

    * 2.分治法：递归->快速傅里叶变换（FFT）


###  1.3. <a name='k'></a>漫画：寻找无序数组的第k大元素
> [漫画：寻找无序数组的第k大元素？](https://mp.weixin.qq.com/s/ZXzXry6ho9tFcOYnmB3AwA)

* 思路1： 排序法 [O(nlogn)]  
排序后第k个元素即为第k大元素。

* 思路2： 插入法 [O(n*k)], 若k很大，还不如思路1

* **思路3**： 小顶堆法 [O(nlogk)]
    * 方法分析  

    * 时间复杂度[O(nlogk)]  
      1.构建堆：O(k)  
      2.遍历剩余数组：O(n-k)  
      3.每次调整堆：O(logk)   
      其中2和3是嵌套关系，1和2、3是并列关系，所以总的最坏时间复杂度为：O((n - k)logk + k),当k远小于n时，近似为：O(nlogk)

    * 空间复杂度[O(1)]  
    若允许改变原数组的话，则可以把数组的前k个元素“原地交换”来构建成二叉堆，这样就免去了开辟额外的存储空间。因此其空间复杂度:O(1)

* **思路4**： 分治法 [O(n)]  
    快速排序

> 参考:
> 《算法导论》
