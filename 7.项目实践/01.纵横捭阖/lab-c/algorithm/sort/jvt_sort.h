/*
 *  jvt_sort.h 
 *  jvt_sort
 *
 *  Created by Jevstein on 2019/02/08 20:16.
 *  Copyright @ 2018year Jevstein. All rights reserved.
 *
 *  参考博客: 《常见排序算法总结与实现(冒泡、插入、选择、希尔、堆排序、归并、快排)》： https://www.cnblogs.com/alsf/p/6606287.html
 *            《谈谈几个常用的排序算法》：https://sylvanassun.github.io/2017/03/20/2017-3-20-sorting_algorithm/
 *  算法比较:
 *           ------------------------------------------------------------------------------
 *           | 排序方法 | 最好时间 | 平均时间 | 最坏时间 | 空间复杂度 | 排序方式 | 稳定性 |
 *           ------------------------------------------------------------------------------
 *         ☆| 直接插入 |   O(n)   |  O(n^2)  |  O(n^2)  |    O(1)    | in-place |  稳定  |
 *           ------------------------------------------------------------------------------
 *           | 二分插入 |   O(n)   |  O(n^2)  |  O(n^2)  |    O(1)    | in-place |  稳定  |
 *           ------------------------------------------------------------------------------
 *           | 希尔排序 |  O(nlgn) | O(n^1.25)| O(nlg^2n)|    O(1)    | in-place | 不稳定 |
 *           ------------------------------------------------------------------------------
 *           | 冒泡排序 |   O(n)   |  O(n^2)  |  O(n^2)  |    O(1)    | in-place |  稳定  |
 *           ------------------------------------------------------------------------------
 *           |鸡尾酒排序|   O(n)   |  O(n^2)  |  O(n^2)  |    O(1)    | in-place |  稳定  |
 *           ------------------------------------------------------------------------------
 *         ★| 快速排序 |  O(nlgn) |  O(nlgn) |  O(n^2)  |   O(lgn)   | in-place | 不稳定 |
 *           ------------------------------------------------------------------------------
 *           | 直接选择 |  O(n^2)  |  O(n^2)  |  O(n^2)  |    O(1)    | in-place | 不稳定 |
 *           ------------------------------------------------------------------------------
 *         ★|  堆排序  |  O(nlgn) |  O(nlgn) |  O(nlgn) |    O(1)    | in-place | 不稳定 |
 *           ------------------------------------------------------------------------------
 *         ☆| 归并排序 |  O(nlgn) |  O(nlgn) |  O(nlgn) |    O(n)    | out-place|  稳定  |
 *           ------------------------------------------------------------------------------
 *         ☆|  桶排序  |  O(n+k)  |  O(n+k)  |  O(n^2)  |   O(n+k)   | out-place|  稳定  |
 *           ------------------------------------------------------------------------------
 *           | 计数排序 |  O(n+k)  |  O(n+k)  |  O(n+k)  |    O(k)    | out-place|  稳定  |
 *           ------------------------------------------------------------------------------
 *           | 基数排序 |  O(n*k)  |  O(n*k)  |  O(n*k)  |   O(n+k)   | out-place|  稳定  |
 *           ------------------------------------------------------------------------------
 *           | 位图排序 |  O(*)  |  O(*  |  O(*  |   O(*)   | out-place|  *  |
 *           ------------------------------------------------------------------------------
 *
 *     稳定：是指不影响值相等元素的相对次序; 即原本键值一样的元素排序后相对位置不变.其意义
 *           如：一个“学生”数组，按照年龄排序，“学生”这个对象不仅含有“年龄”还有其他很多
 *           属性。稳定的排序，就能保证比较时若两个学生年龄相同，不发生交换。
 *
 *     空间复杂度: 一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。如直接插
 *           入排序的空间复杂度是O(1); 而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归
 *           都要存储返回信息。
 *
 *     排序算法选择:
 *              每种排序算法都各有优缺点,根据不同情况适当选用，甚至可以将多种方法结合起来使用。
 *           平均时间复杂度低的算法,并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更
 *           适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，
 *           需要考虑的因素有以下四点：
 *              1．待排序的记录数目n的大小；
 *              2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；
 *              3．关键字的结构及其分布情况；
 *              4．对排序稳定性的要求。
 *           设待排序元素的个数为n.
 *           1） 当n较大，应采用时间复杂度为O(nlgn)的排序方法：“快速排序”、“堆排序”或“归并排序序”。
 *              *“快速排序”：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机
 *                             分布时，快速排序的平均时间最短；
 *              *“堆排序”：
 *              *“归并排序”：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度
 *                             的序列，然后再合并，在效率上将有所提高。
 *              [注]: 当n较大，内存空间允许，且要求稳定性,就选“归并排序”
 *           2）当n较小，可采用直接插入或直接选择排序。
 *              *“直接插入排序”：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。
 *              *“直接选择排序”：元素分布有序，如果不要求稳定性，选择直接选择排序
 *           3）一般不使用或不直接使用传统的“冒泡排序”。
 *           4）“基数排序”，它是一种稳定的排序算法，但有一定的局限性：
 *              1.关键字可分解。
 *              2.记录的关键字位数较少，如果密集更好
 *              3.如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。
 */

#ifndef _JVT_SORT_H_
#define _JVT_SORT_H_

#include "jvt_quick.h"
#include "jvt_merge.h"
#include "jvt_heap.h"
#include "jvt_bucket_.h"
#include "jvt_insertion_.h"
#include "jvt_selection_.h"
#include "jvt_bubble_.h"
#include "jvt_bitmap.h"

#endif//_JVT_SORT_H_