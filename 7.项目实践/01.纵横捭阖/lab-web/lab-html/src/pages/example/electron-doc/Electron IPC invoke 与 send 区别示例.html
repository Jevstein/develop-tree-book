<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electron IPC invoke vs send 示例</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .method {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .method h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .method.send {
            border-left-color: #e74c3c;
        }
        
        .method.invoke {
            border-left-color: #2ecc71;
        }
        
        .demo-area {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            padding: 10px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .output {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        
        .explanation {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background: #f2f2f2;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Electron IPC：invoke 与 send 方法区别</h1>
        
        <div class="explanation">
            <p>在 Electron 中，<code>invoke</code> 和 <code>send</code> 都是用于主进程与渲染进程间通信（IPC）的方法，但它们在用法和功能上有重要区别。</p>
        </div>
        
        <div class="comparison">
            <div class="method send">
                <h3>ipcRenderer.send()</h3>
                <p><strong>单向通信</strong> - 从渲染进程发送消息到主进程，不期待回复。</p>
                <ul>
                    <li>使用 <code>ipcMain.on()</code> 监听</li>
                    <li>不返回 Promise</li>
                    <li>适合发送通知、状态更新等</li>
                </ul>
            </div>
            
            <div class="method invoke">
                <h3>ipcRenderer.invoke()</h3>
                <p><strong>双向通信</strong> - 从渲染进程调用主进程的处理程序，并返回 Promise。</p>
                <ul>
                    <li>使用 <code>ipcMain.handle()</code> 处理</li>
                    <li>返回 Promise，可使用 async/await</li>
                    <li>适合需要返回结果的操作</li>
                </ul>
            </div>
        </div>
        
        <h2>区别对比表</h2>
        <table>
            <thead>
                <tr>
                    <th>特性</th>
                    <th>ipcRenderer.send()</th>
                    <th>ipcRenderer.invoke()</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>通信方向</td>
                    <td>单向（渲染进程 → 主进程）</td>
                    <td>双向（渲染进程 ⇄ 主进程）</td>
                </tr>
                <tr>
                    <td>返回值</td>
                    <td>无返回值</td>
                    <td>返回 Promise</td>
                </tr>
                <tr>
                    <td>错误处理</td>
                    <td>需要手动处理错误</td>
                    <td>Promise 自动处理错误</td>
                </tr>
                <tr>
                    <td>使用场景</td>
                    <td>通知、状态更新、事件触发</td>
                    <td>需要返回数据的操作、函数调用</td>
                </tr>
                <tr>
                    <td>主进程监听</td>
                    <td><code>ipcMain.on()</code></td>
                    <td><code>ipcMain.handle()</code></td>
                </tr>
            </tbody>
        </table>
        
        <div class="demo-area">
            <h2>代码示例演示</h2>
            <p>以下示例展示了两种方法的使用方式（模拟执行，实际需要在 Electron 环境中运行）：</p>
            
            <div class="buttons">
                <button onclick="demoSend()">测试 send 方法</button>
                <button onclick="demoInvoke()">测试 invoke 方法</button>
                <button onclick="clearOutput()">清空输出</button>
            </div>
            
            <div class="output" id="output">输出区域...</div>
        </div>
        
        <h2>完整代码示例</h2>
        
        <h3>渲染进程代码 (renderer.js)</h3>
        <div class="code-block">// 引入 ipcRenderer
const { ipcRenderer } = require('electron');

// 使用 send 方法 - 单向通信
function sendMessageToMain() {
    // 发送消息到主进程，不期待回复
    ipcRenderer.send('send-message', { 
        type: 'notification', 
        data: 'Hello from send' 
    });
    console.log('send消息已发送');
}

// 使用 invoke 方法 - 双向通信
async function invokeMessageToMain() {
    try {
        // 调用主进程的处理程序，并等待结果
        const result = await ipcRenderer.invoke('invoke-message', { 
            type: 'request', 
            data: 'Hello from invoke' 
        });
        console.log('invoke结果:', result);
        return result;
    } catch (error) {
        console.error('invoke错误:', error);
        throw error;
    }
}

// 监听主进程的回复（send 方法需要额外设置）
ipcRenderer.on('send-reply', (event, arg) => {
    console.log('收到主进程回复:', arg);
});</div>

        <h3>主进程代码 (main.js)</h3>
        <div class="code-block">// 引入 ipcMain
const { ipcMain } = require('electron');

// 处理 send 消息
ipcMain.on('send-message', (event, arg) => {
    console.log('收到 send 消息:', arg);
    
    // 处理消息...
    const processedData = processData(arg);
    
    // 如果需要回复，需要手动发送
    event.reply('send-reply', { 
        status: 'success', 
        data: processedData 
    });
});

// 处理 invoke 消息
ipcMain.handle('invoke-message', async (event, arg) => {
    console.log('收到 invoke 消息:', arg);
    
    try {
        // 模拟异步操作
        const result = await someAsyncOperation(arg);
        return { 
            status: 'success', 
            data: result 
        };
    } catch (error) {
        // 错误会自动传递给渲染进程的 Promise reject
        throw new Error(`处理失败: ${error.message}`);
    }
});

// 辅助函数
function processData(data) {
    return `处理后的数据: ${JSON.stringify(data)}`;
}

async function someAsyncOperation(data) {
    // 模拟异步操作
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(`异步处理结果: ${JSON.stringify(data)}`);
        }, 1000);
    });
}</div>

        <h2>使用建议</h2>
        <div class="explanation">
            <p><strong>使用 send 的情况：</strong></p>
            <ul>
                <li>只需要发送通知，不关心回复</li>
                <li>状态更新、事件触发</li>
                <li>简单的单向通信</li>
            </ul>
            
            <p><strong>使用 invoke 的情况：</strong></p>
            <ul>
                <li>需要从主进程获取数据</li>
                <li>需要处理异步操作结果</li>
                <li>需要错误处理</li>
                <li>使用 async/await 更清晰的代码</li>
            </ul>
        </div>
    </div>

    <script>
        // 模拟 Electron IPC 环境下的演示代码
        let outputElement = document.getElementById('output');
        
        // 模拟 ipcRenderer.send 行为
        function demoSend() {
            addOutput('=== 测试 ipcRenderer.send() ===');
            addOutput('发送消息到主进程: {type: "notification", data: "Hello from send"}');
            addOutput('消息已发送（不期待回复）');
            addOutput('如需回复，需要主进程手动调用 event.reply()');
            addOutput('----------------------------------------');
        }
        
        // 模拟 ipcRenderer.invoke 行为
        async function demoInvoke() {
            addOutput('=== 测试 ipcRenderer.invoke() ===');
            addOutput('调用主进程处理程序: {type: "request", data: "Hello from invoke"}');
            
            try {
                // 模拟异步操作
                addOutput('等待主进程处理...');
                const result = await simulateInvokeCall();
                addOutput(`收到结果: ${JSON.stringify(result)}`);
            } catch (error) {
                addOutput(`错误: ${error}`);
            }
            addOutput('----------------------------------------');
        }
        
        // 模拟 invoke 的异步调用
        function simulateInvokeCall() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    // 模拟成功或失败
                    if (Math.random() > 0.2) { // 80% 成功率
                        resolve({ 
                            status: 'success', 
                            data: '处理完成的数据' 
                        });
                    } else {
                        reject(new Error('模拟处理失败'));
                    }
                }, 1000);
            });
        }
        
        function clearOutput() {
            outputElement.textContent = '输出区域...\n';
        }
        
        function addOutput(message) {
            outputElement.textContent += message + '\n';
            outputElement.scrollTop = outputElement.scrollHeight;
        }
        
        // 初始化
        clearOutput();
        addOutput('点击按钮测试不同的 IPC 方法...');
    </script>
</body>
</html>
